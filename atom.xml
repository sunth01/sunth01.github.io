<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunth01</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-26T02:37:21.174Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuex前言</title>
    <link href="http://example.com/2023/04/10/%E5%85%B3%E4%BA%8EVuex/"/>
    <id>http://example.com/2023/04/10/%E5%85%B3%E4%BA%8EVuex/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:37:21.174Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 的安装：npm i vuex</p><p>新建文件夹 store import 引入 Vuex，</p><p>vuex 中的参数：</p><ul><li><strong>state</strong>：{ count：0 } 存储数据</li><li><strong>mutations</strong>：{ updateCount（两个参数，第一个参数是修改的 state、后续调用的传值）{ state.count = num } } ()</li><li><strong>getters</strong> 可以理解为 computed 是为了方便生成一些在组件内可以直接使用的数据，统一产出 state 中的数据，</li><li><strong>actions</strong> （第一个参数是 store，第二个参数是触发这个函数时传入的参数，如果多个参数需要写成对象）actions 可以写异步代码，mutations 不能写异步代码，</li><li>mapactions 和 mapmutations 需要写在 methods 方法中，用法跟 mapGetters 一样</li><li>在 store.js 中 要 ipmort vue 之后 Vue.use（Vuex）</li><li>通过 export defautle store 导出</li><li><img src="https://s2.loli.net/2023/04/17/YJMG6jS4qOnBVmx.png" alt="image-20230415114314480" style="zoom:50%;" /></li></ul><p>在入口文件 index.js 中 先 import 中引入 store 文件，然后在实例上挂载</p><p>使用 store 的方法：直接在应用中 this.$store 调用全局  因为vuex会帮助处理在每个组件内部添加上这个$store 对象，如果要修改 store 中定义的参数，需要使用 this.$store.commit（传入的参数，第一个参数”我们写的 mutations 的名称 updateCount“，第二个参数就是 num 这个值是可选换的，例如 外部声明一个变量 let i = 1 这个 i 就可以作为参数传入 num 的位置）</p><p>store.js 中可以直接 expore default （）=&gt;{ return new Vuex.store 如下图 }</p><img src="C:\Users\86132\AppData\Roaming\Typora\typora-user-images\image-20230415121554719.png" alt="image-20230415121554719" style="zoom:50%;" /><p>在 index.js 中 import 引入 store.js 文件 ，在下面创建一个 store 如下</p><img src="C:\Users\86132\AppData\Roaming\Typora\typora-user-images\image-20230415121816111.png" alt="image-20230415121816111" style="zoom:50%;" /><p><strong>getters 的使用</strong></p><ul><li>在 state 中添加参数</li></ul><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230415122745358.png" alt="image-20230415122745358" style="zoom:50%;" /><p>在 getters 中定义一个方法 传入一个 state 作为参数 返回从 state 中获取到的参数</p><img src="C:\Users\86132\AppData\Roaming\Typora\typora-user-images\image-20230415122819027.png" alt="image-20230415122819027" style="zoom:50%;" /><p>在 computed 中调用 getters 中的方法进行 return 返回 在 vue 文件中使用插值表达式使用，通过 updateCount 的更新修改就会让 getters 中的内容发生改变</p><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230415122908859.png" alt="image-20230415122908859" style="zoom:50%;" /><p>组件内使用 store 可以使用 vuex 中自带的帮助方法，<strong>mapState</strong> 和 <strong>mapGetters</strong> 使用前需要 inport 从 vuex 中引入进来</p><p><strong>mapState</strong> 的作用是 映射$store.state 内定义的参数 ，如下：</p><p>同名情况下</p><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230415124559768.png" alt="image-20230415124559768" style="zoom:50%;" /><p>不同名的情况：</p><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230415124703787.png" alt="image-20230415124703787" style="zoom:50%;" /><p>如果要做计算的情况，可以使用 如下：</p><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230415124752550.png" alt="image-20230415124752550" style="zoom:50%;" /><p><strong>mapGetters</strong> 可以替换 return this.$store.getters.xxx 的内容</p><img src="https://s2.loli.net/2023/04/17/xVQBdcUFqY8seuz.png" alt="image-20230415124958518" style="zoom:50%;" /><p>actions 用在异步代码比如数据请求可以写在这 在组件内触发 actions 需要使用 this. $store. dispatch（第一个参数传入的是 actions 的名字，第二个参数可以是个对象存放需要的内容）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuex 的安装：npm i vuex&lt;/p&gt;
&lt;p&gt;新建文件夹 store import 引入 Vuex，&lt;/p&gt;
&lt;p&gt;vuex 中的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;：{ count：0 } 存储数据&lt;/li&gt;
&lt;li&gt;&lt;s</summary>
      
    
    
    
    
    <category term="sunth05" scheme="http://example.com/tags/sunth05/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router</title>
    <link href="http://example.com/2023/04/10/Vue-Router/"/>
    <id>http://example.com/2023/04/10/Vue-Router/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:37:16.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><ol><li>安装 vue-router 依赖</li><li>再在 min.js 中引入 vue-router</li><li>添加到 Vue.use(VueRouter)</li><li>创建 router 实例 // const router = new VueRouter()</li><li>将路由对象注入到 new Vue 实例中</li></ol><p>router：整个全局最大的路由实例，只有一个<br>routes：路由规则的列表，里面是一个数组，里面的每一条规则又是一个对象 【{}，{}，{}】<br>route：一条路由规则，每一条规则都是一个对象<br>{ path：’/路径’，component：”组件名” } ==&gt; route</p><p><strong>创建路由规则并创建路由实例</strong></p><ul><li>routers 是路由规则数组</li><li>每个路由规则都是一个配置对象，其中至少包含 path 和 component 两个属性</li><li>path 表示当前路由规则匹配的 hash 地址</li><li>component 表示当前路由规则对应要展示的组件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var router = new VueRouter(&#123; routes:[ &#123;path:&#x27;/&#x27;,redirect:&#x27;/user&#x27;&#125;</span><br><span class="line">&#123;path:&#x27;/user&#x27;,commponent:User&#125;, &#123;path:&#x27;/register&#x27;,component:Register&#125; ] &#125;) //</span><br><span class="line">最后在new Vue中奖router挂载到Vue根实例中</span><br></pre></td></tr></table></figure><p><strong>路由重定向</strong></p><ul><li>通过路由规则的 redirect 属性，指定一个新的路由地址</li><li>{ path:’/‘,redirect:’/user’ }</li><li>当用户在地址栏中输入 “/” ，会自动跳转到 ”/user“ 而 /user 对应的组件为 User</li></ul><p><strong>props 接收参数</strong></p><ul><li><p>props 为布尔类型时：</p></li><li><img src="https://s2.loli.net/2023/04/17/d7DcUKej4FyJz5k.png" alt="image-20230417201850655" style="zoom:50%;" /></li><li><p>props 的值为对象类型时：</p></li><li><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230417201956598.png" alt="image-20230417201956598" style="zoom:50%;" /></li><li><p>props 的值为函数类型时：</p></li><li><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230417202030571.png" alt="image-20230417202030571" style="zoom:50%;" /></li></ul><p><strong>命名路由</strong></p><ul><li>在配置路由项中添加 name：“xxx”，使用时 如</li><li><router-lonk :to="{name:'user',params:{id:123}}"></router-link></li></ul><p><strong>编程式导航</strong></p><ul><li>通过调用 js 形式的 API 实现导航的方式叫做编程式导航</li><li>例如：普通网页中的 location. href</li><li>this. $router.push ( ‘ hash 地址 ‘ ) — 跳转的实现，参数不仅可以传递字符串（路径名称），也可以传递对象、命名的路由（传递参数）、带查询参数，变成 /register?uname=lisi</li><li><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230417202641848.png" alt="image-20230417202641848" style="zoom:50%;" /></li><li>this. $router. go ( n ) —- 后退的实现（参数是-1 -2 等）</li></ul><p><strong>声明式导航</strong></p><ul><li>点击链接实现导航的方式，叫做声明式导航</li><li>例如：普通网页的 a 标签、或者 vue 中的 router-link</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装 vue-router 依赖&lt;/li&gt;
&lt;li&gt;再在 min</summary>
      
    
    
    
    
    <category term="sunth04" scheme="http://example.com/tags/sunth04/"/>
    
  </entry>
  
  <entry>
    <title>重要又记不住</title>
    <link href="http://example.com/2023/04/10/%E8%84%B1%E4%BF%9D%E5%BF%85%E5%A4%87/"/>
    <id>http://example.com/2023/04/10/%E8%84%B1%E4%BF%9D%E5%BF%85%E5%A4%87/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:37:11.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pomise"><a href="#Pomise" class="headerlink" title="Pomise"></a>Pomise</h2><ul><li>三个状态 成功/失败/初始化</li><li>promise.all() // 所有的 promise 全部成功则返回成功，其中一个失败就返回失败</li><li>promise.race() // 对比返回最快的 promise，如果最快的 promise 失败，则失败，race 只管最快的，不管其他的 promise</li><li>promise.resolve() // 直接创建一个从成功的 promise</li><li>promise.reject() // 直接创建一个失败的 promise</li></ul><h2 id="弹窗组件封装"><a href="#弹窗组件封装" class="headerlink" title="弹窗组件封装"></a>弹窗组件封装</h2><ul><li><p>简单的使用：只是父组件传数据到子组件，—使用 props 即可实现</p><blockquote><p>在 components 文件夹中新建一个 MyDialog.vue 组件，在 App.vue 中 import 导入 mydialog 组件，在 components 中引入 mydialog 并在页面使用 mydialog 标签，在父组件中 mydialog 的标签上定义一个属性，在 mydialog 组件中使用 props 接收父组件传递的参数，在其要显示的内容处使用插值表达式的方式使用定义的属性名</p></blockquote></li><li><p>如果想要实现组件的内部某些自定义结构，—需要使用 solt 插槽</p><blockquote><p>在子组件 mydialog 想要定义内容的位置放置 solt 插槽</p></blockquote><h2 id="Ajax、Fetch、Axios-三者的区别吗？"><a href="#Ajax、Fetch、Axios-三者的区别吗？" class="headerlink" title="Ajax、Fetch、Axios 三者的区别吗？"></a>Ajax、Fetch、Axios 三者的区别吗？</h2><blockquote><p>最大的特性就是局部刷新页面，无需重载整个页面。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Pomise&quot;&gt;&lt;a href=&quot;#Pomise&quot; class=&quot;headerlink&quot; title=&quot;Pomise&quot;&gt;&lt;/a&gt;Pomise&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;三个状态 成功/失败/初始化&lt;/li&gt;
&lt;li&gt;promise.all() // 所有的 pro</summary>
      
    
    
    
    
    <category term="sunth03" scheme="http://example.com/tags/sunth03/"/>
    
  </entry>
  
  <entry>
    <title>项目难点亮点</title>
    <link href="http://example.com/2023/04/10/%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E4%BA%AE%E7%82%B9/"/>
    <id>http://example.com/2023/04/10/%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E4%BA%AE%E7%82%B9/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T03:15:49.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><ul><li>分为三个区域，可视区域，滚动区域，占位区域</li><li>可视区域的高度小于滚动区域，可视区域包裹着滚动区域，滚动区域包裹着占位区域，可视区域要加属性 overflow-y：auto 进行隐藏滚动区域高出来的数据部分，实现滚动效果，可视区域固定一个高度用来显示数据，滚动区域的高度是动态的（高度是 用数据每一项的高度 乘以 总数据的条数），占位区域的高度是动态的 （高度是 用滚动上去第几项数据的索引值 乘以 单条数据的高度） 来实现占位区域的高度，使用 e.target.scorlltop 来监听滚动条的位置高度，使用这个高度除以每一项元素的高度 就是当前滚动到第几项数据的索引值，然后在 computed 计算属性中定义一个存放十条数据的数组，使用 arr.slice 截取出总数据条数的前十条进行 return 返回来，在页面上使用 for in 循环遍历 存放十条数据的数组然后渲染到页面上，实现虚拟列表</li><li>虚拟列表是按需显示的一种实现，既对可视区域进行渲染，非可视区域不渲染或者部分渲染，从而达到极高的渲染性能，简单说就是首屏加载的时候，只加载可视区域的内容，当滚动发生时，动态的计算获得可视区域内的列表项，并将非可视区域的内容进行删除</li><li>初始化一个变量 存放当前数据的索引值： 0</li><li>监听滚动事件，通过 e.target.socrlltopp 获取到滚动条的位置（既距离顶部的位置），通过 Math.floor 计算出 现在的 currentindex 所对应的索引值（使用获取到的滚动条的位置除以每一项的高度），给可视区域固定的高度展示数据（添加 overflow-y：auto），获取到滚动区域的总高度（数据的 length _ 30 px），给展位区域设置高度（当前滚动到数据的索引值 _ 30），用 computed 计算属性定义一个空数组 displayarr，使用 arr.slice 从全部数据中提取进行出来十条数据然后 return，然后 for in 循环遍历 displayarr 把每一项数据进行渲染，实现虚拟列表</li></ul><h2 id="拖拉拽"><a href="#拖拉拽" class="headerlink" title="拖拉拽"></a>拖拉拽</h2><h2 id="canvas-签名"><a href="#canvas-签名" class="headerlink" title="canvas 签名"></a>canvas 签名</h2><p>用 canvas 跳过 dom 操作直接画图，是比浏览器原生的 dom 操作更好，而且用 canvas 可以快速的生成图片</p><p>定义 canvas 画布大小</p><p>使用 canvas。getContext（“2d”）拿到画笔</p><p>使用 ctx。rect 画出绘制区域（四个参数：前两个为坐标点，后面两个为 绘制区域的大小）</p><p>使用 ctx。stroke（）画笔进行绘制，用 strokeStyle 定义绘制区域的描边颜色</p><p>用 ctx。fillStyle（）定义绘制区域的填充颜色，</p><p>绘制完之后用 canvas。clearRect 清空绘制版，</p><hr><p>先定义画板 canvas 的大小为绘制区域，使用 canvas。getContext（”2d“）作为画笔，用 window。addEventListener（”mousedown“）监听 mousedown 鼠标按下，并判断鼠标是否在画板上按下的，所以需要获取到画板位置的大小（canvas。getBoundingClienRect（））使用 e。clientX 和 clientY 获取到鼠标点击的位置并判断是否小于画板位置的大小，我们可以称之为<strong>命中检测</strong> 如果在画板内部就注册两个监听器，监听 mousemove 鼠标移动和 mouseup 鼠标抬起，传入一个方法 draw，draw 方法中也有一个事件，在这里我们美监听一次 draw 事件就要接着上次的画，所以要计算出画笔的一个具体位置，这个位置是相对于整个 canvas 的具体位置，用 ctx。beginPath（）准备开始描线，ctx。moveTo（x，y）是画笔的起始点，ctx。lineTo（）是画笔的终点，ctx。stroke（）进行描线，然后更新起点，生成签名。给 button 按钮绑定点击事件，初始化一个变量接收 canvas。toDataURL（）生成 base64 的图片</p><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><blockquote><p><strong>背景：</strong> 文件导入的时候如果文件过大，可能会导致所需时间过长，且失败后需要重新上传<br><strong>思路</strong></p></blockquote><ul><li><p>对文件做切片，既将一个请求切分成多个请求，每个请求的时间会缩短，如果某个请求失败的话，只需要发送这一次请求即可，无需从头开始<br>配置请求基地址，指示后续的请求应发向哪个服务器地址,监听 input 框 file 的 onChange 事件，当用户选择文件上传时，将其存储在全局变量 file 中</p></li><li><p>通知服务器合并切片，在上传完切片后，前端通知服务器做合并切片操作</p></li><li><p>控制多个请求的并发量，防止多个请求同时发送，造成浏览器内存溢出，导致页面卡死</p></li><li><p>做断点续传，当多个请求中有请求发送失败，例如出现网络故障、页面关闭等，我们得对失败的请求做处理，让它们重复发送</p></li></ul><h2 id="Excel-导入导出"><a href="#Excel-导入导出" class="headerlink" title="Excel 导入导出"></a>Excel 导入导出</h2><h2 id="websocket-大屏"><a href="#websocket-大屏" class="headerlink" title="websocket 大屏"></a>websocket 大屏</h2><h2 id="webRTC-直播"><a href="#webRTC-直播" class="headerlink" title="webRTC 直播"></a>webRTC 直播</h2><h2 id="无感刷新-Token"><a href="#无感刷新-Token" class="headerlink" title="无感刷新 Token"></a>无感刷新 Token</h2><ul><li>在响应拦截器返回 403/404，表示 token 失效后,在响应拦截器里盘点本地 userInfo 里面是不是有 refrenToken，如果有，调用 axios，传参对应接口路径、请求办法，请求头新加 refrenToken（注意！！ 不能使用上面已经封装的 request ＝ axios.create，因为它的请求头一直为失效的 token,再调用也会报错，需要调用原生 axios，配置 refreshToken 的新的请求头）。发生请求返回更新的 token 后，替换存储在本地失效的 token，再重新发送最开始因为 token 失效而报错的请求即可（此处好像可以直接传参 error.config 就包含了所以信息）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;虚拟列表&quot;&gt;&lt;a href=&quot;#虚拟列表&quot; class=&quot;headerlink&quot; title=&quot;虚拟列表&quot;&gt;&lt;/a&gt;虚拟列表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分为三个区域，可视区域，滚动区域，占位区域&lt;/li&gt;
&lt;li&gt;可视区域的高度小于滚动区域，可视区域包裹着滚动区域</summary>
      
    
    
    
    
    <category term="sunth02" scheme="http://example.com/tags/sunth02/"/>
    
  </entry>
  
  <entry>
    <title>小程序</title>
    <link href="http://example.com/2023/04/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2023/04/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:20:26.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><ol><li>onLoad 页面开始加载 发送请求获取数据,获取到导航参数</li><li>onShow 页面显示 (多次触发) 提示信息</li><li>onReady 页面初次渲染完成</li><li>onHide 页面隐藏 tabbar 页面切换只是隐藏</li><li>onUnload 页面销毁 不是 tabbar 页面 b 页面 返回 A 页面对应的页面销毁 // 清理操作</li></ol><h2 id="原生小程序组件及如何绑定事件"><a href="#原生小程序组件及如何绑定事件" class="headerlink" title="原生小程序组件及如何绑定事件"></a>原生小程序组件及如何绑定事件</h2><ul><li>通过 bind: 或者 bind 绑定事件</li><li>常用的小程序组件<ul><li>view: 盒子</li><li>text: 文本</li><li>richtext: 富文本,可以通过 nodes 节点解析 html 标签</li><li>scroll-view: 滚动区域</li><li>swiper: 轮播图</li><li>button: 按钮组件</li></ul></li></ul><h2 id="原生小程序中如何修改数据并同步视图"><a href="#原生小程序中如何修改数据并同步视图" class="headerlink" title="原生小程序中如何修改数据并同步视图?"></a>原生小程序中如何修改数据并同步视图?</h2><ul><li>this.setData(), 既可以更改数据,也可以同步视图</li><li>不可以直接修改数据, 直接 this.data.数据名, 之更改数据,视图不变</li></ul><h2 id="小程序中发起网络请求"><a href="#小程序中发起网络请求" class="headerlink" title="小程序中发起网络请求"></a>小程序中发起网络请求</h2><ul><li>通过 WX.request,而且这个方法不支持 promise,所使用原生小程序开发,需要对 wx.request 进行二次封装</li><li>小程序中不存在跨域的问题</li></ul><h2 id="定义全局组件和局部组件"><a href="#定义全局组件和局部组件" class="headerlink" title="定义全局组件和局部组件"></a>定义全局组件和局部组件</h2><p><strong>全局组件</strong></p><ol><li>创建一个组件</li><li>通过 app.json 中的 useingComponets 进行组件注册,注册为全局组件</li></ol><p><strong>局部组件</strong></p><ol><li>创建一个组件</li><li>通过页面的 json 中的 useingComponets 进行组件注册,注册为局部组件</li></ol><h2 id="查询参数传参"><a href="#查询参数传参" class="headerlink" title="查询参数传参"></a>查询参数传参</h2><ul><li>在 router-link 上的 to 属性传值，语法格式：/path？参数名=值</li><li>对应页面组件接收传递过来的值 语法格式：$route. query. 参数名</li></ul><h2 id="动态路由传参"><a href="#动态路由传参" class="headerlink" title="动态路由传参"></a>动态路由传参</h2><ul><li>目标：在跳转路由时，可以给路由对应的组件内传值</li><li>在 router-link 上的 to 属性传值，语法格式：<ul><li>/path？参数名 = 值</li><li>/path/值 - 需要路由对象提前配置 path：“/path/参数名”</li></ul></li><li>对应页面组件接收传递过来的值<ul><li>$route. query. 参数名</li><li>$route. params. 参数名</li><li><img src="C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230424191628777.png" alt="image-20230424191628777"></li></ul></li></ul><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &quot;/&quot;, // 默认hash值路径 redirect: &quot;/find&quot; // 重定向到/find //</span><br><span class="line">浏览器url中#后的路径被改变成/find-重新匹配数组规则 &#125;</span><br></pre></td></tr></table></figure><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="hash-和-history"><a href="#hash-和-history" class="headerlink" title="hash 和 history"></a>hash 和 history</h3><ul><li>hash 在地址栏会有#号<ul><li>用 window.location.hash 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中，hash 不会重加载页面</li></ul></li><li>history 地址栏没有#<ul><li>history 采用 HTML5 的新特性；且提供了两个新方法：pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及 popState 事件的监听的状态变更</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小程序生命周期&quot;&gt;&lt;a href=&quot;#小程序生命周期&quot; class=&quot;headerlink&quot; title=&quot;小程序生命周期&quot;&gt;&lt;/a&gt;小程序生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;onLoad 页面开始加载 发送请求获取数据,获取到导航参数&lt;/li&gt;
&lt;li&gt;onSh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="http://example.com/2023/04/10/Vue3/"/>
    <id>http://example.com/2023/04/10/Vue3/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:37:31.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue3-选项式-API"><a href="#Vue3-选项式-API" class="headerlink" title="Vue3 选项式 API"></a>Vue3 选项式 API</h2><p>只有一个参数，不会出现参数顺序的问题，随意调整配置的位置</p><p>语义化强</p><p>双花括号中不能放 js 语句，可以放表达式，函数，数组，字符串等</p><p>vue 底层利用 new porxy 来把 data 中的数据监控起来，不管用什么方法对数据进行修改，就会触发重渲染，内部的重渲染就会对试图进行更新</p><p>v-bind：绑定对应的标签如（v-bind：class/title。。。），可以使标签变成响应式的绑定数据 —-简写 –&gt; :title</p><p>v-on：添加事件 如（v-on：click/mouse。。。）–&gt; 简写—&gt; @click</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue3-选项式-API&quot;&gt;&lt;a href=&quot;#Vue3-选项式-API&quot; class=&quot;headerlink&quot; title=&quot;Vue3 选项式 API&quot;&gt;&lt;/a&gt;Vue3 选项式 API&lt;/h2&gt;&lt;p&gt;只有一个参数，不会出现参数顺序的问题，随意调整配置的位置&lt;/</summary>
      
    
    
    
    
    <category term="sunth07" scheme="http://example.com/tags/sunth07/"/>
    
  </entry>
  
  <entry>
    <title>讲一下自己</title>
    <link href="http://example.com/2023/04/10/%E4%B8%AD%E5%BC%8F%E6%96%99%E7%90%86/"/>
    <id>http://example.com/2023/04/10/%E4%B8%AD%E5%BC%8F%E6%96%99%E7%90%86/</id>
    <published>2023-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:37:27.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="讲一下自己"><a href="#讲一下自己" class="headerlink" title="讲一下自己"></a>讲一下自己</h1><p>面试官你好，我叫孙世鑫，20 年毕业，当时因为校招来到成都工作，毕业后先后就职于两家公司工作（成都新维思创科技有限公司，四川无声易动科技有限公司），目前使用的技术栈是 Vue 全家桶，原生小程序，uniapp，熟悉原生 javascript/H5 新特性 Es6，，可以配合前端组件库快速还原设计图，</p><h3 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3><p><strong>虚拟列表</strong> 之前做的一个细胞因子检测项目，里面有个模块需要渲染大量数据，但是因为数据量太大会导致渲染加载太慢过载，然后使用的是虚拟列表的方式实现的</p><p>先定义一个初始化变量用来存放当前数据的索引值，实现虚拟列表至少需要三个区域，可视区域，占位区域，滚动区域，给可视区域添加一个 overflow-y：auto 实现滚动效果，固定其高度，给每一条数据设置一个固定的高度，然后监听滚动事件（e.target.socrlltop）获取到滚动条的位置，计算得出当前高度所对应的数据索引为为多少，在 computed 计算属性中定义个空数组，暂且称它为 arrayA，然后用 arr.slice 从全部数据取出所需要的条数进行 return，在页面 for in 渲染出 arrayA 的数据，实现虚拟列表，从而达到按需显示、极高渲染性能的效果。</p><p><strong>canvas 签名</strong></p><p>用 canvas 跳过 dom 操作直接画图，是比浏览器原生的 dom 操作更好，而且用 canvas 可以快速的生成图片</p><p>定义 canvas 画布大小</p><p>使用 canvas。getContext（“2d”）拿到画笔</p><p>使用 ctx。rect 画出绘制区域（四个参数：前两个为坐标点，后面两个为 绘制区域的大小）</p><p>使用 ctx。stroke（）画笔进行绘制，用 strokeStyle 定义绘制区域的描边颜色</p><p>用 ctx。fillStyle（）定义绘制区域的填充颜色，</p><p>绘制完之后用 canvas。clearRect 清空绘制版，</p><p>============================</p><p>先定义画板 canvas 的大小为绘制区域，使用 canvas。getContext（”2d“）作为画笔，用 window。addEventListener（”mousedown“）监听 mousedown 鼠标按下，并判断鼠标是否在画板上按下的，所以需要获取到画板位置的大小（canvas。getBoundingClienRect（））使用 e。clientX 和 clientY 获取到鼠标点击的位置并判断是否小于画板位置的大小，我们可以称之为<strong>命中检测</strong> 如果在画板内部就注册两个监听器，监听 mousemove 鼠标移动和 mouseup 鼠标抬起，传入一个方法 draw，draw 方法中也有一个事件，在这里我们美监听一次 draw 事件就要接着上次的画，所以要计算出画笔的一个具体位置，这个位置是相对于整个 canvas 的具体位置，用 ctx。beginPath（）准备开始描线，ctx。moveTo（x，y）是画笔的起始点，ctx。lineTo（）是画笔的终点，ctx。stroke（）进行描线，然后更新起点，生成签名。给 button 按钮绑定点击事件，初始化一个变量接收 canvas。toDataURL（）生成 base64 的图片</p><h3 id="ES6-新增"><a href="#ES6-新增" class="headerlink" title="ES6 新增"></a>ES6 新增</h3><p>新增声明命令 let const，模板字符串，inport 和 export，poemise，数组对象的解构赋值，set 数据结构 ：（size 数据长度，add 添加某个值，返回 set 结构本身，clear 清除所有成员，没有返回值），class，展开运算符，</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><ul><li>以函数形式调用时，this 永远都是 window</li><li>以方法的形式调用时，this 是调用方法的对象</li><li>以构造函数的形式调用时，this 是新创建的那个对象</li><li>使用 call 和 apply 调用时，this 是指定的那个对象</li><li>箭头函数：箭头函数的 this 看外层是否有函数如果有，外层函数的 this 就是内部箭头函数的 this 如果没有，就是 window</li></ul><h3 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h3><p>创建阶段</p><ul><li>beforeCreate：开始创建实例，现在还没有实例的数据和方法</li><li>created：实例创建完成，数据和方法已经存在了，精虫在这发送请求获取数据</li></ul><p>挂载阶段</p><ul><li>beforemount：开始挂载 dom，真正的 dom 元素还没有挂载完成，不能操作 dom</li><li>mounted：dom 元素挂载完成，可以操作 dom 元素</li></ul><p>更新阶段</p><ul><li>beforeUpdate：数据变了，视图没有变化</li><li>updated：数据和视图都变了</li></ul><p>销毁阶段</p><ul><li>beforeDestory：即将销毁</li><li>destoryed：组件销毁</li></ul><h3 id="H5-新特性"><a href="#H5-新特性" class="headerlink" title="H5 新特性"></a>H5 新特性</h3><ul><li>拖拽释放</li><li>自定义属性</li><li>画布 Canvas</li><li>本地存储</li><li>表单控件 ： date，url，time</li></ul><h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><ul><li>新增 RGBA 模式</li><li>文字阴影</li><li>边框圆角，边框阴影</li><li>背景</li><li>弹性布局</li><li>字体图标 iconfont</li></ul><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p><strong>**flex-grow**</strong> 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间</p><p><strong>**flex-shrink**</strong> 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p><p><strong>**flex-basis**</strong> 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小</p><h3 id="关于跨域"><a href="#关于跨域" class="headerlink" title="关于跨域"></a>关于跨域</h3><ul><li><p>跨域产生的原因主要是同源策略，同源策略是浏览器提供的一种安全机制，可以防止跨站脚本攻击。也就是 A 网站请求 B 网站的资源，是否能够使用的问题</p></li><li><p>同源策略：协议（http/https）、域名/IP 地址、端口号，一致则同源，代表是同一个网站，资源共享，有一项不同既不同源，代表是两个网站，此时资源不共享</p></li></ul><h4 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h4><ul><li><strong>JSONP</strong> 利用的不是 xhr 请求, 利用的 script 标签的 src 可以跨域, 请求接口资源,同时携带 callback 回调函数名字, 将数据传给回调函数, 解决 get 不能解决 post</li><li><strong>后端开启 CORS 跨域资源共享</strong>（就是在 http 的响应头里设置一个字段 Access-Control-Allow-Origin：* ）本服务器允许任何人来请求，前端正常请求，浏览器发现这个端口允许跨域，所以不报错拿到数据给前端用</li><li>代理转发，本地自己 node+http 搭建一个 web 服务，用服务器去请求另外一个服务器的接口把数据请求回来转发给自己的前端使用（服务器与服务器之间不存在跨域问题，即使地址不同）前端请求本地的这个服务器，而不能直接请求后端（用于后端正常提供接口，但不开启 CORS 的情况）</li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li>父盒子开启 flex,并设置主轴居中,侧轴居中</li><li>父盒子开启 flex,子盒子设置 margin:auto</li><li>子绝父相,子盒子设置 top 和 left 值为 50%,利用 transform 基于自身回去-50%</li><li>子绝父项,子盒子设置上下左右均为 0,在设置 margin:auto 也可以</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul><li>四部分: 内容+内边距+外边距+边框</li><li>盒模型可以进行切换: box-sizing: border-box; ie 盒模型/c3 盒模型/怪异盒模型, 宽高定死,不受边框内间距撑开</li><li>默认是 content-box: 标准盒模型, width+内间距+边框</li></ul><h3 id="Object-defineProperty-和-Proxy-的区别"><a href="#Object-defineProperty-和-Proxy-的区别" class="headerlink" title="Object.defineProperty 和 Proxy 的区别"></a>Object.defineProperty 和 Proxy 的区别</h3><ul><li>Proxy 可以直接监听对象而非属性</li><li>Proxy 可以直接监听数组的变化</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改</li></ul><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><p>响应式是 Vue 的核心特性之一，数据驱动视图，我们修改数据视图随之响应更新，<code>Vue2 是借助</code>Object.defineProperty()<code>实现的，而</code>Vue3<code>是借助</code>Proxy`实现的，Proxy 相比 Object.defineProperty 在处理数组和新增属性的响应式处理上更加方便。</p><p>我们通过<code>Object.defineProperty</code>为对象添加属性，可以设置对象属性的<code>getter</code>和<code>setter</code>函数。之后我们每次通过点语法获取属性都会执行这个<code>getter</code>函数，在这个函数中我们会把调用此属性的依赖收集到一个集合中，当我们给属性赋值(修改属性)时，会触发这里定义的<code>setter</code>函数，通过这个<code>setter</code>函数去通知集合中的依赖更新，做到数据变更驱动视图变更。</p><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>vue 是一个 mvvm 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化</p><p>双向数据绑定通常是指我们使用的<code>v-model</code>指令的实现，是<code>Vue</code>的一个特性，也可以说是一个<code>input</code>事件和<code>value</code>的语法糖。 <code>Vue</code>通过<code>v-model</code>指令为组件添加上<code>input</code>事件处理和<code>value</code>属性的赋值。</p><ul><li><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过</p><p>Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></li></ul><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>Model</code>（模型）</p><ul><li>模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）</li></ul><p><code>View</code>（视图）</p><ul><li>视图是用户在屏幕上看到的结构、布局和外观</li></ul><p><code>ViewModel</code>（视图模型）</p><ul><li>视图模型是暴露公共属性和命令的视图的抽象。MVVM 没有 MVC 模式的控制器，有一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</li><li><strong>优点</strong>：低耦合:<code>View</code>可以独立于<code>Model</code>变化和修改,一个<code>ViewModel</code>可以绑定到不同的<code>View</code>上,当<code>View</code>变化的时候<code>Model</code>可以不变,当<code>Model</code>变化的时候<code>View</code>也可以不变。</li><li>可重用性: 可以把一些视图逻辑放在一个<code>ViewModel</code>里面,让很多<code>View</code>重用这段视图逻辑</li></ul><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 分为:<code>Model</code>(模型),<code>View</code>(视图),<code>Controller</code>(控制器）</p><p>M：Model，数据模型，Model 定义了这个模块的数据模型，Model 负责对数据进行获取及存放</p><p>MVC 是<strong>单向通信</strong> 所以 model 和 view 之间必须通过 contriller 联系，也就是在 Controller 里面把 Model 的数据赋值给 View 来显示 （或者是 View 接收用户输入的数据然后由 Controller 把这些数据传给 Model 来保存到本地或者上传到服务器）</p><h2 id="MVC-和-MVVM-区别"><a href="#MVC-和-MVVM-区别" class="headerlink" title="MVC 和 MVVM 区别"></a>MVC 和 MVVM 区别</h2><p>MVC 和 MVVM 的区别并不是 VM 完全取代了 C，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用。</p><h3 id="小程序支付"><a href="#小程序支付" class="headerlink" title="小程序支付"></a>小程序支付</h3><ol><li>注册微信商户号</li><li>点击按钮触发 wx.requestPayment，进行预付费（用户付费），通知微信</li><li>微信返回加密信息和交易信息</li><li>拿着这些信息发给服务器（商户）</li><li>服务器向微信确认</li><li>交易完成，前端监听交易情况</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;讲一下自己&quot;&gt;&lt;a href=&quot;#讲一下自己&quot; class=&quot;headerlink&quot; title=&quot;讲一下自己&quot;&gt;&lt;/a&gt;讲一下自己&lt;/h1&gt;&lt;p&gt;面试官你好，我叫孙世鑫，20 年毕业，当时因为校招来到成都工作，毕业后先后就职于两家公司工作（成都新维思创科技有限公</summary>
      
    
    
    
    
    <category term="sunth06" scheme="http://example.com/tags/sunth06/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://example.com/2022/04/10/Vue%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2022/04/10/Vue%E7%9A%84%E5%86%85%E5%AE%B9/</id>
    <published>2022-04-10T11:04:25.000Z</published>
    <updated>2023-04-26T02:36:12.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-中选择器的优先级以及-CSS-权重如何计算？"><a href="#CSS-中选择器的优先级以及-CSS-权重如何计算？" class="headerlink" title="CSS 中选择器的优先级以及 CSS 权重如何计算？"></a>CSS 中选择器的优先级以及 CSS 权重如何计算？</h2><ul><li>！Important&gt;行内样式&gt;ID 选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性权重</li></ul><h2 id="key-的作用"><a href="#key-的作用" class="headerlink" title="key 的作用"></a>key 的作用</h2><ul><li>key 必须是字符串或者数值类型,不能是对象或数组等非基本类型的数据</li><li>key 的作用：</li><li>遍历的时候 :key=”唯一标识” 可以表示元素的唯一性,可以更好的进行新旧虚拟 dom 的对比,提高了对比的复用性</li><li>key 在遍历数组的时候 :key=’唯一’</li><li>有 id 用 id ,有唯一值用唯一值,实在没有 ,才用索引 index</li></ul><h2 id="1-问题-什么是作用域链？"><a href="#1-问题-什么是作用域链？" class="headerlink" title="(1)问题: 什么是作用域链？"></a>(1)问题: 什么是作用域链？</h2><ul><li>当代码在一个环境中执行时，会创建变量对象的一个作用域链 由子级作用域返回父级作用域中寻找变量，就叫做作用域链<br>作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自下一个包含环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后一个对象，<br>作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象</li></ul><h2 id="2-问题-说说你对原型（prototype）理解"><a href="#2-问题-说说你对原型（prototype）理解" class="headerlink" title="(2)问题: 说说你对原型（prototype）理解?"></a>(2)问题: 说说你对原型（prototype）理解?</h2><ul><li>JavaScript 中所有都是对象，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript 的函数对象中都包含了一个” prototype”内部属性，这个属性所对应的就是该函数对象的原型<br>“prototype”作为函数对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox 和 Chrome 内核的 JavaScript 引擎中提供了”proto“这个非标准的访问器<blockquote><p>原型的主要作用就是为了实现继承与扩展对象</p></blockquote></li></ul><h2 id="3-问题-ES5-和-ES6-的区别，说几个-ES6-的新增方法"><a href="#3-问题-ES5-和-ES6-的区别，说几个-ES6-的新增方法" class="headerlink" title="(3)问题: ES5 和 ES6 的区别，说几个 ES6 的新增方法?"></a>(3)问题: ES5 和 ES6 的区别，说几个 ES6 的新增方法?</h2><ul><li><h6 id="ES5-和-ES6-的区别"><a href="#ES5-和-ES6-的区别" class="headerlink" title="ES5 和 ES6 的区别"></a>ES5 和 ES6 的区别</h6><p>ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化<br>ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015<br>ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率</p></li><li><h6 id="ES6-的新增方法"><a href="#ES6-的新增方法" class="headerlink" title="ES6 的新增方法:"></a>ES6 的新增方法:</h6><ul><li><h2 id="新增声明命令-let-和-const"><a href="#新增声明命令-let-和-const" class="headerlink" title="新增声明命令 let 和 const"></a>新增声明命令 let 和 const</h2></li><li><h2 id="在-ES6-中通常用-let-和-const-来声明，let-表示变量、const-表示常量"><a href="#在-ES6-中通常用-let-和-const-来声明，let-表示变量、const-表示常量" class="headerlink" title="在 ES6 中通常用 let 和 const 来声明，let 表示变量、const 表示常量"></a>在 ES6 中通常用 let 和 const 来声明，let 表示变量、const 表示常量</h2></li><li><h2 id="特点：let-和-const-都是块级作用域。以-代码块作为作用域范围-只能在代码块里面使用，不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区”-在同一个代码块内，不允许重复声明"><a href="#特点：let-和-const-都是块级作用域。以-代码块作为作用域范围-只能在代码块里面使用，不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区”-在同一个代码块内，不允许重复声明" class="headerlink" title="特点：let 和 const 都是块级作用域。以{}代码块作为作用域范围 只能在代码块里面使用，不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区” 在同一个代码块内，不允许重复声明"></a>特点：let 和 const 都是块级作用域。以{}代码块作为作用域范围 只能在代码块里面使用，不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区” 在同一个代码块内，不允许重复声明</h2></li><li><h2 id="const-声明的是一个只读常量，在声明时就需要赋值。（如果-const-的是一个对象，对-象所-包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而-变量成员是可以修改的。）"><a href="#const-声明的是一个只读常量，在声明时就需要赋值。（如果-const-的是一个对象，对-象所-包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而-变量成员是可以修改的。）" class="headerlink" title="const 声明的是一个只读常量，在声明时就需要赋值。（如果 const 的是一个对象，对 象所 包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而 变量成员是可以修改的。）"></a>const 声明的是一个只读常量，在声明时就需要赋值。（如果 const 的是一个对象，对 象所 包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而 变量成员是可以修改的。）</h2></li></ul></li><li><h2 id="模板字符串（Template-String）"><a href="#模板字符串（Template-String）" class="headerlink" title="模板字符串（Template String）"></a>模板字符串（Template String）</h2><ul><li><h2 id="用一对反引号-标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以-在字符串中嵌入变量，js-表达式或函数，变量、js-表达式或函数需要写在-中。"><a href="#用一对反引号-标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以-在字符串中嵌入变量，js-表达式或函数，变量、js-表达式或函数需要写在-中。" class="headerlink" title="用一对反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以 在字符串中嵌入变量，js 表达式或函数，变量、js 表达式或函数需要写在${ }中。"></a>用一对反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以 在字符串中嵌入变量，js 表达式或函数，变量、js 表达式或函数需要写在${ }中。</h2></li></ul></li><li><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2></li><li><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li><h2 id="在-ES6-中，提供了一种简洁的函数写法，我们称作“箭头函数"><a href="#在-ES6-中，提供了一种简洁的函数写法，我们称作“箭头函数" class="headerlink" title="在 ES6 中，提供了一种简洁的函数写法，我们称作“箭头函数"></a>在 ES6 中，提供了一种简洁的函数写法，我们称作“箭头函数</h2></li><li><h2 id="写法-函数名-形参-gt-……-当函数体中只有一个表达式时，-和-return-可以省-略当函数体中形参只有一个时，-可以省略"><a href="#写法-函数名-形参-gt-……-当函数体中只有一个表达式时，-和-return-可以省-略当函数体中形参只有一个时，-可以省略" class="headerlink" title="写法 函数名=(形参)=&gt;{……}当函数体中只有一个表达式时，{}和 return 可以省 略当函数体中形参只有一个时，()- 可以省略"></a>写法 函数名=(形参)=&gt;{……}当函数体中只有一个表达式时，{}和 return 可以省 略当函数体中形参只有一个时，()- 可以省略</h2></li><li><h2 id="箭头函数中的-this-始终指向箭头函数定义时的离-this-最近的一个函数，如果没有最"><a href="#箭头函数中的-this-始终指向箭头函数定义时的离-this-最近的一个函数，如果没有最" class="headerlink" title="箭头函数中的 this 始终指向箭头函数定义时的离 this 最近的一个函数，如果没有最"></a>箭头函数中的 this 始终指向箭头函数定义时的离 this 最近的一个函数，如果没有最</h2><p>近的函数就指向 window</p></li></ul></li><li><p>对象的扩展</p></li><li><p>import 和 export</p></li><li><p>Promise 对象</p></li><li><p>解构赋值</p></li></ul><p>Set 数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。</p><ul><li><p>Set 属性和方法</p></li><li><p>Size（） 数据的长度</p></li><li><p>Add（） 添加某个值，返回 Set 结构本身。</p></li><li><p>Delete（） 删除某个值，返回一个布尔值，表示删除是否成功。</p></li><li><p>Has（） 查找某条数据，返回一个布尔值。</p></li><li><p>Clear（）清除所有成员，没有返回值。<br>async、await</p></li><li><p>使用 async/await, 搭配 Promise,可以通过编写形似同步的代码来处理异步流程, 提高代码 的简洁性和可读性 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方 法执行完成<br>…</p></li><li><p>展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量</p></li></ul><h2 id="4-问题-介绍-this-各种情况"><a href="#4-问题-介绍-this-各种情况" class="headerlink" title="(4)问题: 介绍 this 各种情况?"></a>(4)问题: 介绍 this 各种情况?</h2><ul><li>以函数形式调用时，this 永远都是 window</li><li>以方法的形式调用时，this 是调用方法的对象</li><li>以构造函数的形式调用时，this 是新创建的那个对象</li><li>使用 call 和 apply 调用时，this 是指定的那个对象</li><li>箭头函数：箭头函数的 this 看外层是否有函数如果有，外层函数的 this 就是内部箭头函数的 this 如果没有，就是 window</li><li>特殊情况：通常意义上 this 指针指向为最后调用它的对象。这里需要注意的一点就是如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例</li></ul><h2 id="关于计算属性"><a href="#关于计算属性" class="headerlink" title="关于计算属性"></a>关于计算属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="title function_">sum</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">num1</span> + <span class="variable language_">this</span>.<span class="property">num2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6 简写形式更多一些</li><li><ol><li> 计算属性，必须是一个函数</li></ol></li><li><ol start="2"><li> 这个函数一定要写一个 return，必须要有返回值</li></ol></li><li><ol start="3"><li> 计算属性函数中的 this 指向的也是 vue 实例，如果要取 data 中的变量 ，this.xx</li></ol></li><li><ol start="4"><li> 计算属性使用的时候，和 data 里面的数据一样，不能加()当做方法来调用！</li></ol></li><li><ol start="5"><li> 计算属性的变量名不能和 data 中的变量名一样</li></ol></li></ul><h2 id="计算属性相比函数调用的优势"><a href="#计算属性相比函数调用的优势" class="headerlink" title="计算属性相比函数调用的优势"></a>计算属性相比函数调用的优势</h2><ul><li>多次使用的时候，计算属性有缓存，性能消耗小</li><li>特点</li><li><ol><li>计算属性会缓存结果，只要依赖项不改变，就直接读取缓存</li></ol></li><li><ol start="2"><li>依赖项改变，函数重新执行并缓存最新的结果</li></ol></li><li>使用场景</li><li>=&gt;当某个值依赖其他值的时候，就可以使用计算属性。</li><li><ol><li> 求和 ， 求平均值</li></ol></li><li><ol start="2"><li> 全选反选等</li></ol></li></ul><h2 id="关于-BFC"><a href="#关于-BFC" class="headerlink" title="关于 BFC"></a>关于 BFC</h2><ul><li>BFC Block Formatting Context 块级格式化上下文</li><li>创建了一个独立的空间，独立的容器，内部和外部的布局等互不干扰。</li><li>==&gt; BFC 是一个完全独立的空间（布局环境），让空间里的子元素不会影响到 -</li><li>触发条件（怎么创建一个 BFC）</li><li><ol><li>overflow:hidden</li></ol></li><li><ol start="2"><li>float:left / right</li></ol></li><li><ol start="3"><li>position:absolute / fixed;</li></ol></li><li><ol start="4"><li>display:inline-block / flex / table -</li></ol></li><li>外边距塌陷：==&gt; 上下两个盒子，都有 margin， 取 margin -</li><li>应用场景：</li><li><ol><li>防止外边距塌陷</li></ol></li><li><ol start="2"><li>清浮动，（包含浮动元素），计算 BFC 高度的时候，浮动的子元素也会参与计算。</li></ol></li></ul><h2 id="5-为什么会有跨域问题的出现？怎么解决跨域？"><a href="#5-为什么会有跨域问题的出现？怎么解决跨域？" class="headerlink" title="(5)为什么会有跨域问题的出现？怎么解决跨域？"></a>(5)为什么会有跨域问题的出现？怎么解决跨域？</h2><ul><li>由于 Web 浏览器的同源策略所导致的，是一种安全策略，同源是指两个 URL 具有相同的协议、主机和端口号。如果两个 URL 的任何一个部分不同，就被认为是不同源。当一个 Web 页面通过 JavaScript 代码访问来自不同源的资源时，浏览器就会禁止这种行为，这就是跨域问题的根源。</li><li>JSONP（JSON with padding）：使用 <code>&lt;script&gt;</code> 标签进行跨域数据传输，服务器端将数据封装到回调函数中，前端使用回调函数接收数据。但是 JSONP 只支持 GET 请求，并且存在安全风险。</li><li>代理服务器：在客户端与服务端之间增加一个代理服务器，使客户端与代理服务器的通信符合同源策略，再由代理服务器与目标服务器进行通信，避免跨域问题。</li><li>CORS（Cross-Origin Resource Sharing）：通过在服务器端设置响应头信息来允许跨域访问，允许指定特定域名下的请求。</li></ul><h2 id="6-Vuex-的-5-个核心属性"><a href="#6-Vuex-的-5-个核心属性" class="headerlink" title="(6)Vuex 的 5 个核心属性"></a>(6)Vuex 的 5 个核心属性</h2><ul><li>state：在 state 中需要定义我们所需要管理的数组、对象、字符串等</li><li>getters：当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getter，getter 会接收 state 作为第一个参数，而且 getter 的返回值会根据它的依赖被缓存起来，只有 getter 中的依赖值发生改变的时候才会被重新计算</li><li>mutation ：更改 store 中 state 状态的唯一方法就是提交 mutation，每个 mutation 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函数中改变。要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit</li><li>action ：</li><li>action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有任何的异步操作。如果我们要调用这个 action，则需要执行 store.dispatch</li><li>module ：module 可以将 store 分割成模块，使得应用程序更易于扩展和维护，每个模块中拥有自己的 state、mutation、action 和 getter</li></ul><h2 id="7-EventLoop-事件循环机制"><a href="#7-EventLoop-事件循环机制" class="headerlink" title="(7)EventLoop 事件循环机制"></a>(7)EventLoop 事件循环机制</h2><ul><li><p>宏任务：</p><ul><li><ol><li>script 代码块</li></ol></li><li><ol start="2"><li>setTimeout / setInterval</li></ol></li><li><ol start="3"><li>setImmediate</li></ol></li></ul></li><li><p>微任务：</p><ul><li><ol><li>promise.then() 和 promise.catch()</li></ol></li><li><ol start="2"><li>async await （await 这一行的代码，同步执行的）（await 后面的代码会放到微任务队列中）</li></ol></li><li><ol start="3"><li>MutationObserver</li></ol></li><li><ol start="4"><li>process.nextTick</li></ol></li></ul></li><li><ol><li>首先 script 代码块可以看做第一个宏任务，开始第一个 Tick 事件循环</li></ol></li><li><ol start="2"><li>会先执行 script 代码块中的同步代码，</li></ol></li><li><ol start="3"><li>如果遇到宏任务，就放到宏任务队列中等待执行, 如果遇到微任务，放到微任务队列中</li></ol></li><li><ol start="4"><li>当主线程执行完同步代码的时候，首先，去微任务队列中清空当前事件循环的所有微任务 （本轮事件循环 Tick 结束）</li></ol></li><li><ol start="5"><li>再去执行下一个宏任务 ==&gt; 重复执行，直到宏任务队列和微任务队列都为空。</li></ol></li><li><p>需要注意的是，事件循环机制中的微任务具有高优先级，会优先于宏任务执行。因此，在事件循环中，每次执行完一个宏任务后，会立即执行产生的所有微任务，而不是等待下一个宏任务执行时再执行微任务。</p></li></ul><h2 id="8-路由传值的方式有哪几种"><a href="#8-路由传值的方式有哪几种" class="headerlink" title="(8)路由传值的方式有哪几种"></a>(8)路由传值的方式有哪几种</h2><ul><li>查询参数传值（Query Parameter）：在 URL 路径后面加上问号 “?” 和参数名以及参数值，使用 “&amp;” 符号分隔多个参数，如 ：<a href="http://www.example.com/?id=123&amp;name=foo">http://www.example.com?id=123&amp;name=foo</a></li><li>对象 : 想要传递参数主要就是以对象的方式来写，分为两种方式：命名路由、查询参数<ul><li>this.$router.push( { <strong>name</strong>:”news”, <strong>params</strong> : { userId : 123 } ) （命名路由 这种方式传递参数，目标页面刷新会报错）</li><li>this.$router.push( { <strong>path</strong>:”/news’, <strong>query</strong> : { uersId : 123 } )  接收参数 this.$route.query （查询参数 和 name 配对的式 params，和 path 配对的是 query）</li></ul></li></ul><h2 id="9-怎么定义-Vue-Router-的动态路由-怎么获取传过来的动态参数"><a href="#9-怎么定义-Vue-Router-的动态路由-怎么获取传过来的动态参数" class="headerlink" title="(9)怎么定义 Vue-Router 的动态路由?怎么获取传过来的动态参数?"></a>(9)怎么定义 Vue-Router 的动态路由?怎么获取传过来的动态参数?</h2><ul><li><p>在定义动态路由时，需要在路由的 path 中添加动态参数，使用冒号（:）表示参数名。</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/users/:userId&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">User</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">路由的path中添加了一个动态参数:userId，这个参数可以匹配任意的数字或字符串。当访问/users/<span class="number">123</span>时，路由会匹配到这个动态路由，并将参数传递给对应的组件。</span><br></pre></td></tr></table></figure></li><li><p>可以通过$route.params 来获取动态参数的值，</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line"><span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.userId &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">$route.<span class="property">params</span>.<span class="property">userId</span>会获取到动态参数的值，例如当访问/users/<span class="number">123</span>时，$route.<span class="property">params</span>.<span class="property">userId</span>的值就是<span class="number">123</span>，就可以根据不同的动态参数来展示不同的内容。</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-query-和-params-之间的区别是什么"><a href="#10-query-和-params-之间的区别是什么" class="headerlink" title="(10)query 和 params 之间的区别是什么"></a>(10)query 和 params 之间的区别是什么</h2><ul><li>query 要用 path 来引入，params 要用 name 来引入</li><li>接收参数时，分别是 this.$route.query.name 和 this.$route.params.name（注意：是$route而不是$router）</li></ul><h2 id="11-如何进行性能优化"><a href="#11-如何进行性能优化" class="headerlink" title="(11)如何进行性能优化"></a>(11)如何进行性能优化</h2><ul><li>减少 HTTP 请求</li><li>减少 DOM 操作</li><li>页面懒加载</li></ul><h2 id="12-项目中的-axios-怎么使用？"><a href="#12-项目中的-axios-怎么使用？" class="headerlink" title="(12)项目中的 axios 怎么使用？"></a>(12)项目中的 axios 怎么使用？</h2><ul><li><p>npm i axios 安装依赖</p></li><li><p>import axios from ‘axios’ 导入</p></li><li><p>用于在客户端和服务器之间发送 HTTP 请求，首先导入了 axios 模块，然后使用 <code>axios.get</code> 方法发出 GET 请求。该方法的第一个参数是要请求的 URL，第二个参数是可选的配置对象。我们链式调用 <code>.then</code> 和 <code>.catch</code> 方法来处理成功和失败的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&quot;/api/data&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他类型的请求（例如 POST、PUT 或 DELETE），例如 <code>axios.post</code>、<code>axios.put</code> 或 <code>axios.delete</code>。还可以通过将配置对象作为第二个参数传递给这些方法来定制请求的详细信息，例如请求头、请求体等等。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .<span class="title function_">post</span>(</span><br><span class="line">    <span class="string">&quot;/api/data&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      <span class="attr">email</span>: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>示例中，我们使用 axios.post 方法发送 POST 请求，请求体包含一个 JSON 对象，请求头指定了内容类型为 JSON。<br>需要注意的是，axios 返回的是一个 Promise 对象，因此您可以使用 async/await 或 .then/.catch 进行异步处理。</p></li></ul><h2 id="系统如何进行权限控制和实现"><a href="#系统如何进行权限控制和实现" class="headerlink" title="系统如何进行权限控制和实现?"></a>系统如何进行权限控制和实现?</h2><h2 id="如何区分数组和对象？"><a href="#如何区分数组和对象？" class="headerlink" title="如何区分数组和对象？"></a>如何区分数组和对象？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 通过<span class="keyword">typeof</span>判断大多基本的数据类型</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>  <span class="comment">// number</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 通过<span class="keyword">instanceof</span>判断一个对象是否属于某个特定的构造函数</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Date</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> 可以返回一个对象的类型，格式为<span class="string">&quot;[object Type]&quot;</span>，其中<span class="title class_">Type</span>表示对象的类型。</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])  <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)  <span class="comment">// &quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="title class_">Array</span>.<span class="property">isArray</span>方法：可以判断一个对象是否为数组。</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h2><h2 id="vue-页面如何做缓存控制？"><a href="#vue-页面如何做缓存控制？" class="headerlink" title="vue 页面如何做缓存控制？"></a>vue 页面如何做缓存控制？</h2><h2 id="讲讲-excel-导入和导出的实现"><a href="#讲讲-excel-导入和导出的实现" class="headerlink" title="讲讲 excel 导入和导出的实现?"></a>讲讲 excel 导入和导出的实现?</h2><h2 id="Vue-数据双向绑定的原理是什么"><a href="#Vue-数据双向绑定的原理是什么" class="headerlink" title="Vue 数据双向绑定的原理是什么?"></a>Vue 数据双向绑定的原理是什么?</h2><ul><li>Vue 数据双向绑定的原理是利用了 JavaScript 的 <code>Object.defineProperty()</code> 方法实现的。</li><li>当一个 Vue 实例创建时，Vue 会对实例中的数据进行劫持，即使用 <code>Object.defineProperty()</code> 方法将数据转换成 getter 和 setter，在数据被读取和修改时，可以触发相应的回调函数，实现数据的响应式更新。这样，在 Vue 模板中使用这些数据时，Vue 可以将模板和数据建立起双向绑定的关系，即数据的变化会自动反映在模板中，模板的变化也会自动反映在数据中。</li><li>具体来说，当模板中的数据被修改时，Vue 会通过 setter 方法将修改的值存储到相应的数据中，然后触发更新。在更新时，Vue 会重新渲染相关的组件和 DOM，将修改后的数据显示出来。同时，如果数据的依赖发生变化，Vue 会重新计算依赖，触发相关的回调函数。</li><li>总之，Vue 数据双向绑定的原理是将数据转换成 getter 和 setter，在数据变化时触发相应的回调函数，实现数据的响应式更新，并且通过依赖追踪，自动更新相关的组件和 DOM。</li></ul><h2 id="Vue-的路由实现模式：hash-模式和-history-模式"><a href="#Vue-的路由实现模式：hash-模式和-history-模式" class="headerlink" title="Vue 的路由实现模式：hash 模式和 history 模式?"></a>Vue 的路由实现模式：hash 模式和 history 模式?</h2><p><strong>hash 模式</strong>：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取。hash 不会重新加载页面。</p><p><strong>history 模式</strong>：history 采用 HTML5 的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是指在一个函数内部定义的函数，它可以访问外部函数的变量和参数，即使在外部函数已经执行完毕的情况下也能够保持对这些变量和参数的引用，在 JavaScript 中，闭包是通过使用函数嵌套来实现的。内部函数可以访问外部函数的变量和参数，因为在创建内部函数时，JavaScript 引擎会将外部函数的作用域链添加到内部函数的作用域链中，从而使得内部函数可以访问外部函数的变量和参数。当外部函数执行完毕后，闭包仍然可以保持对外部函数的作用域链的引用，因此它可以在需要时访问外部函数的变量和参数。</p><p>优点是 延伸了变量的作用范围 因为闭包函数中的局部变量不会等着闭包函数执行完就销毁, 因为还有别的函数要调用它 , 只有等着所有的函数都调用完了他才会销毁，<br>缺点是内存泄漏 内存泄漏就是内存空间使用完毕之后未回收)即所谓内存泄漏。</p><h2 id="相较于-Promise，async-await-有以下几个优势："><a href="#相较于-Promise，async-await-有以下几个优势：" class="headerlink" title="相较于 Promise，async/await 有以下几个优势："></a>相较于 Promise，async/await 有以下几个优势：</h2><ul><li>更加易读易写：async/await 的语法相比 Promise 更加简洁易懂，更加符合人们的思维习惯，降低了代码的复杂度和维护成本。<br>更加优雅的错误处理：在 Promise 中，错误处理需要通过 catch 方法或者 then 方法的第二个参数来处理，而在 async/await 中，可以使用 try/catch 语法来处理错误，使代码更加优雅。</li><li>更加方便的串行异步操作：在 Promise 中，如果有多个异步操作需要依次执行，需要使用 then 方法链式调用，而在 async/await 中，可以使用 for 循环或者数组的 reduce 方法等方式实现更加方便的串行异步操作。</li><li>更加直观的调试过程：在使用 async/await 的情况下，调试器可以更加方便地捕捉和显示异常信息，提高了调试的效率。</li><li>需要注意的是，在底层实现上，async/await 本质上仍然是基于 Promise 实现的，因此它们的性能基本相当。选择使用哪种技术，取决于个人习惯和具体情况。</li></ul><h2 id="如何判断-JavaScript-的数据类型？"><a href="#如何判断-JavaScript-的数据类型？" class="headerlink" title="如何判断 JavaScript 的数据类型？"></a>如何判断 JavaScript 的数据类型？</h2><ul><li>typeof 可以用来区分除了 null 类型以外的原始数据类型</li><li>instanceof 不能用于判断原始数据类型的数据</li><li>Object.prototype.toString.call()</li><li>Array.isArray([]) // true</li></ul><h2 id="创建函数的几种方式？"><a href="#创建函数的几种方式？" class="headerlink" title="创建函数的几种方式？"></a>创建函数的几种方式？</h2><ul><li>第一种（函数声明）function sum1(num1,num2){return num1+num2}</li><li>第二种（函数表达式）var sum2 = function(num1,num2){return num1+num2}</li><li>第三种（函数对象方式）var sum3 = new Function(“num1”,”num2”,”return num1+num2”)</li></ul><h2 id="JavaScript-内置的常用对象有哪些？并列举该对象常用的方法"><a href="#JavaScript-内置的常用对象有哪些？并列举该对象常用的方法" class="headerlink" title="JavaScript 内置的常用对象有哪些？并列举该对象常用的方法"></a>JavaScript 内置的常用对象有哪些？并列举该对象常用的方法</h2><ul><li>length 属性 动态获取数组长度</li><li>join() 将一个数组转成字符串。返回一个字符串。</li><li>reverse() 将数组中各元素颠倒顺序</li><li>delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)</li><li>shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。</li><li>pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。</li><li>unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，“b，“c”)</li><li>push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，“c”)</li><li>concat( ) 连接数组</li><li>slice( ) 返回数组的一部分</li><li>sort( ) 对数组元素进行排序</li><li>splice( ‘起始位置，从哪儿添加’, 0, 添加的元素) 插入、删除或替换数组的元素</li><li>toLocaleString( ) 把数组转换成局部字符串</li><li>toString( ) 将数组转换成一个字符串</li><li>forEach 遍历所有元素</li></ul><h2 id="遍历数组的方法"><a href="#遍历数组的方法" class="headerlink" title="遍历数组的方法"></a>遍历数组的方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>循环;</span><br><span class="line"><span class="keyword">let</span> aArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; aArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; aArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = aArr[i];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">aArr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> aArr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">aArr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// prev,上一次调用回调返回的值</span></span><br><span class="line"><span class="comment">// curr 当前被处理的元素</span></span><br><span class="line">aArr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(curr);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj123 = &#123; <span class="attr">name</span>: <span class="string">&quot;严佩伦&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">city</span>: <span class="string">&quot;北京&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj123) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;obj123[key]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj123);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> iitem <span class="keyword">of</span> items) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iitem, obj123[iitem]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(obj123);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj123);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何区分数组和对象？-1"><a href="#如何区分数组和对象？-1" class="headerlink" title="如何区分数组和对象？"></a>如何区分数组和对象？</h2><ul><li>Array.isArray([ ]) //true</li><li><input disabled="" type="checkbox"> instanceof Array //true</li><li>{ }.constructor //返回 object</li><li>Object.prototype.toString.call([ ]) //[“object Array”]</li></ul><h2 id="封装-vue-组件的过程"><a href="#封装-vue-组件的过程" class="headerlink" title="封装 vue 组件的过程"></a>封装 vue 组件的过程</h2><ul><li>需求：页面中可以复用的结构，样式及功能等单独抽离成一个文件，实现复用</li><li><ol><li>使用 Vue.cpmpont 方法注册组件，子组件需要数据，可以在 props 中定义数据，而子组件修改好数据之后想要传递给父组件，则需要$emit 方法向外抛出</li></ol></li><li><ol start="2"><li>如果需要给组件传入模板，则定义为插槽 slot</li></ol></li><li><ol start="3"><li>如果需要 父组件主动调用子组件的方法 可以在 methods 选项中开放方法</li></ol></li></ul><h2 id="Vue-组件如何进行传值"><a href="#Vue-组件如何进行传值" class="headerlink" title="Vue 组件如何进行传值"></a>Vue 组件如何进行传值</h2><ul><li>父传子</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>子传父</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>兄弟传参</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue-中的-data-为什么是函数"><a href="#Vue-中的-data-为什么是函数" class="headerlink" title="Vue 中的 data 为什么是函数"></a>Vue 中的 data 为什么是函数</h2><ol><li>每个组件都是 Vue 的实例。</li><li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他,造成变量污染</li><li>组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间</li></ol><h2 id="组件中的-name-选项有什么用？"><a href="#组件中的-name-选项有什么用？" class="headerlink" title="组件中的 name 选项有什么用？"></a>组件中的 name 选项有什么用？</h2><ol><li>使用 keep-alive 时，可搭配组件 name 进行缓存过滤</li><li>DOM 做递归组件时需要调用自身 name</li><li>Vue-devtools 调试工具里显示的组见名称是由 Vue 中组件 name 决定的</li></ol><h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a>关于生命周期</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccd16fe2d1942e699bde7a7971c26a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="生命周期.webp"></p><h2 id="什么是跨域？跨域的解决方案有哪些？"><a href="#什么是跨域？跨域的解决方案有哪些？" class="headerlink" title="什么是跨域？跨域的解决方案有哪些？"></a>什么是跨域？跨域的解决方案有哪些？</h2><blockquote><p><strong>解决方案</strong></p><ul><li>方案一：前端+后端，支持 jsonp 方式请求 -&gt; 仅支持 GET 方式，不支持 POST 方式，原理：利用不受同源策略的标签来实现</li><li>方案二：后端开启 CORS 跨域资源共享（就是在 http 的响应头里设置一个字段 Access-Control-Allow-Origin：* ）本服务器允许任何人来请求，前端正常请求，浏览器发现这个端口允许跨域，所以不报错拿到数据给前端用</li><li>方案三：代理转发，本地自己 node+http 搭建一个 web 服务，用服务器去请求另外一个服务器的接口把数据请求回来转发给自己的前端使用（服务器与服务器之间不存在跨域问题，即使地址不同）前端请求本地的这个服务器，而不能直接请求后端（用于后端正常提供接口，但不开启 CORS 的情况）</li></ul></blockquote><h2 id="关于-flex"><a href="#关于-flex" class="headerlink" title="关于 flex"></a>关于 flex</h2><blockquote><p><strong>flex1</strong> 代表什么意思</p><ul><li><strong>flex</strong> 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选</li><li><strong>flex-grow</strong> 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间</li><li><strong>flex-shrink</strong> 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</li><li><strong>flex-basis</strong> 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小</li><li><strong>所以 flex: 1 表示的含义是等分剩余空间。</strong></li><li>align-items 属性定义项目在交叉轴上如何对齐。</li><li>justify-content 属性定义了项目在主轴上的对齐方式。</li></ul></blockquote><h2 id="Vue2-的缺陷"><a href="#Vue2-的缺陷" class="headerlink" title="Vue2 的缺陷"></a>Vue2 的缺陷</h2><ul><li><p>Object.defineProperty，或者 Vue2 的缺陷</p></li><li><ol><li>针对对象 Vue 无法检测 property 的添加或移除</li></ol></li><li><ol start="2"><li>但是可以使用 Vue.set 或者 this.$set 给嵌套对象添加响应式属性</li></ol></li><li><p>vm.a ==&gt; proxy()</p></li><li><p>Vue.set(vm.data, ‘’)</p></li><li><p>console.log(vm.obj)</p></li><li><p>全局的 Vue.set 方法 （哪个对象，哪个属性，值）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS-中选择器的优先级以及-CSS-权重如何计算？&quot;&gt;&lt;a href=&quot;#CSS-中选择器的优先级以及-CSS-权重如何计算？&quot; class=&quot;headerlink&quot; title=&quot;CSS 中选择器的优先级以及 CSS 权重如何计算？&quot;&gt;&lt;/a&gt;CSS 中选择器</summary>
      
    
    
    
    
    <category term="sunth01" scheme="http://example.com/tags/sunth01/"/>
    
  </entry>
  
</feed>
